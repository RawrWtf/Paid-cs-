local PastebinURL = "https://pastebin.com/raw/NfjU6p15"

local success, HWIDTable = pcall(function()
    return loadstring(game:HttpGet(PastebinURL))()
end)

if not success or typeof(HWIDTable) ~= "table" then
    warn("Failed to load whitelist! Check your internet or Pastebin link.")
    print(HWIDTable) -- shows the error
    return
end

local MyHWID = game:GetService("RbxAnalyticsService"):GetClientId()

local Whitelisted = false
for _, hwid in ipairs(HWIDTable) do
    if hwid == MyHWID then
        Whitelisted = true
        break
    end
end


if Whitelisted then
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Pixeluted/adoniscries/main/Source.lua",true))()
		local Players = game:GetService("Players")
		local LocalPlayer = Players.LocalPlayer
		local Mouse = LocalPlayer:GetMouse()
		local UserInputService = game:GetService("UserInputService")
		local HttpService = game:GetService("HttpService")
		local Camera = workspace.CurrentCamera


		local CoreGui = game:GetService("CoreGui")
		for _, v in ipairs(CoreGui:GetDescendants()) do
			if v:IsA("ScreenGui") and v.Name == "Obsidian" then
				v:Remove()
			end
		end

		-- Load libraries
		local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
		local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/appealaccepted/UI_LIB/refs/heads/main/ReworkedErrors.lua"))()
		local ThemeManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/appealaccepted/ThemeManager/refs/heads/main/ThemeManager.lua"))()
		local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

		-- Library configuration
		Library.ForceCheckbox = false
		Library.ShowToggleFrameInKeybinds = true

		local Options = Library.Options
		local Toggles = Library.Toggles

		-- Constants
		local DISABLED_MESSAGE = "Feature Disabled!"

		-- Teleport locations
		local TELEPORT_LOCATIONS = {
			["Dealership"] = CFrame.new(432, 90, -362),
			["Gun Shop 1"] = CFrame.new(-718, 64, -256),
			["Bank"] = CFrame.new(191, 90, -170),
			["Secret Shop"] = CFrame.new(997, 231, -495),
			["Barber Shop"] = CFrame.new(49, 90, -46),
			["Black Market"] = CFrame.new(-796, 45, 562),
			["Clothing Store"] = CFrame.new(113, 90, -40),
			["Mcdonald's"] = CFrame.new(965, 130, 86),
			["Sell Built Guns"] = CFrame.new(395, 120, 219),
			["Gun Shop 2"] = CFrame.new(508, 184, 155),
			["Hitman Job"] = CFrame.new(-1336, 50, 433),
			["Ice Box"] = CFrame.new(218, 90, 142),
			["NightClub"] = CFrame.new(-474, 206, 136),
			["Packet Fruit"] = CFrame.new(-2371, 50, 661),
			["Pawn Shop"] = CFrame.new(194, 91, -34),
			["Sell Printed Bills"] = CFrame.new(91, 132, 532),
			["Sell Fries"] = CFrame.new(815, 91, 575),
			["Sell Plants"] = CFrame.new(756, 228, -127),
			["Studio"] = CFrame.new(-35768, 18, -270),
			["Supply Store"] = CFrame.new(-450, 51, 403),
			["Swiper Cards"] = CFrame.new(-603, 51, 587),
			["Tatto Shop"] = CFrame.new(985, 131, -102),
			["Trap House"] = CFrame.new(-56, 80, -136),
			["Laundromat"] = CFrame.new(-708, 50, 279),
			["Gun Palace"] = CFrame.new(-167, 105, -210),
			["Chop Chop"] = CFrame.new(242, 101, 2672),
			["BackPack Shop"] = CFrame.new(-181, 90, 275)


		}

		-- Success notification
		Library:Notify({
			Title = "Successfully Loaded Script!",
			Description = "Developed by peter",
			Time = 2,
		})

		-- Create main window
		local Window = Library:CreateWindow({
			Title = "Rawr.WTF",
			Footer = "[VERSION : NEWEST]",
			Icon = 0,
			NotifySide = "Right",
			ShowCustomCursor = true,
		})

		-- Create tabs
		local Tabs = {
			Main = Window:AddTab("Main", "user"),
			Visuals = Window:AddTab("Visuals", "brick-wall"),
			["UI Settings"] = Window:AddTab("UI Settings", "settings"),
		}

		-- Player Section
		local PlayerSection = Tabs.Main:AddLeftGroupbox("Player Options", "user")



		-- WalkSpeed Slider
		PlayerSection:AddSlider("WalkSpeed", {
			Text = "WalkSpeed",
			Default = 0,
			Min = 0,
			Max = 200,
			Rounding = 0,
			Compact = false,
			Callback = function(Value)
				walkrape = Value
			end,
			Tooltip = "Adjust player walk speed",
			DisabledTooltip = DISABLED_MESSAGE
		})

		local MyButton = PlayerSection:AddButton({
			Text = "Apply WalkSpeed",
			Func = function()
				local lp = game.Players.LocalPlayer
				local humanoid = lp.Character:WaitForChild("Humanoid")

				local mt = getrawmetatable(game)
				setreadonly(mt, false)

				local old; old = hookmetamethod(game, "__newindex", function(self, key, value)
					if self == humanoid and key == "WalkSpeed" then
						return old(self, key, walkrape) -- forces 100
					end
					return old(self, key, value)
				end)

				setreadonly(mt, true)

			end,
			DoubleClick = false,

			Tooltip = "Apply WalkSpeed Selected",
			DisabledTooltip = "I am disabled!",

			Disabled = false, -- Will disable the button (true / false)
			Visible = true, -- Will make the button invisible (true / false)
			Risky = false, -- Makes the text red (the color can be changed using Library.Scheme.Red) (Default value = false)
		})

		-- JumpPower Slider
		PlayerSection:AddSlider("JumpPower", {
			Text = "JumpPower",
			Default = 0,
			Min = 0,
			Max = 200,
			Rounding = 1,
			Compact = false,
			Callback = function(Value)
				jumprape = Value
			end,
			Tooltip = "Adjust player jump power",
			DisabledTooltip = DISABLED_MESSAGE
		})

		local MyButton = PlayerSection:AddButton({
			Text = "Apply JumpPower",
			Func = function()
				local lp = game.Players.LocalPlayer
				local humanoid = lp.Character:WaitForChild("Humanoid")

				local mt = getrawmetatable(game)
				setreadonly(mt, false)

				local old; old = hookmetamethod(game, "__newindex", function(self, key, value)
					if self == humanoid and key == "JumpPower" then
						return old(self, key, jumprape) -- forces 100
					end
					return old(self, key, value)
				end)

				setreadonly(mt, true)

			end,
			DoubleClick = false,

			Tooltip = "Applys JumpPower Selected",
			DisabledTooltip = "I am disabled!",

			Disabled = false, -- Will disable the button (true / false)
			Visible = true, -- Will make the button invisible (true / false)
			Risky = false, -- Makes the text red (the color can be changed using Library.Scheme.Red) (Default value = false)
		})

		local originalPrompts = {}
		PlayerSection:AddToggle("InstantInteract", {
			Text = "Instant Interact",
			Tooltip = "0 HoldDuration",
			Default = false,
			Callback = function(Value)
				Library:Notify({
					Title = "Instant Interact",
					Description = Value and "Enabled" or "Disabled",
					Time = 2,
				})

				for _, prompt in ipairs(workspace:GetDescendants()) do
					if prompt:IsA("ProximityPrompt") then
						if Value then
							if not originalPrompts[prompt] then
								originalPrompts[prompt] = prompt.HoldDuration
							end
							prompt.HoldDuration = 0
						else
							if originalPrompts[prompt] then
								prompt.HoldDuration = originalPrompts[prompt]
							end
						end
					end
				end
			end
		})

		local staminaEnabled = false
		local staminaConnection = nil

		PlayerSection:AddToggle("InstantInteract", {
			Text = "Infinite Stamina",
			Tooltip = "Never Run Out Of stam",
			Default = false,
			Callback = function(Value)

			end,
		})

		PlayerSection:AddToggle("InstantInteract", {
			Text = "Infinite Hunger",
			Tooltip = "Never Run Out Of Hunger",
			Default = false,
			Callback = function(Value)

				local hunger = game:GetService("Players").LocalPlayer.PlayerGui.MainScreen.Profile.Hunger.HungerLocal

				if Value then
					hunger.Enabled = false
				else
					hunger.Enabled = true
				end
			end,
		})

		PlayerSection:AddToggle("InstantInteract", {
			Text = "No Ragdoll",
			Tooltip = "Makes You Not Fall",
			Default = false,
			Callback = function(Value)
				Library:Notify({
					Title = "No Radgdoll",
					Description = Value and "Enabled" or "Disabled",
					Time = 2,
				})

				local ragdollscript = game.Players.LocalPlayer.Character.RagdollClient

				if Value then
					ragdollscript.Enabled = false
				end

				if not Value then
					ragdollscript.Enabled = true
				end

			end,
		})

		local moneysec = Tabs.Main:AddLeftGroupbox("Money", "circle-dollar-sign")

		local MyButton = moneysec:AddButton({
			Text = "Infinite Money",
			Func = function()
				local args = {
					"Dogecoin",
					1
				}
				game:GetService("ReplicatedStorage"):WaitForChild("StockMarketRemotes"):WaitForChild("BuyCrypto"):FireServer(unpack(args))
				task.wait(0.1)

				local args = {
					"Dogecoin",
					10000000000
				}
				game:GetService("ReplicatedStorage"):WaitForChild("StockMarketRemotes"):WaitForChild("SellCrypto"):FireServer(unpack(args))

				Library:Notify({
					Title = "Infinite Money",
					Description = "Enjoy",
					Time = 2,
				})

			end,
			DoubleClick = false,

			Tooltip = "Infinite Money",
			DisabledTooltip = "I am disabled!",

			Disabled = false, -- Will disable the button (true / false)
			Visible = true, -- Will make the button invisible (true / false)
			Risky = false, -- Makes the text red (the color can be changed using Library.Scheme.Red) (Default value = false)
		})
		

		local purchase = Tabs.Main:AddLeftGroupbox("Auto Purchase", "shopping-cart")

		local gunfolder = game:GetService("ReplicatedStorage").Elements.ItemsFolder


		local guns = {}
		for _, sticks in pairs(gunfolder:GetChildren()) do
			table.insert(guns, sticks.Name)
		end

		purchase:AddDropdown("TeleportDropdown", {
			Values = guns,
			Default = 1,
			Text = "Purchase Items",
			Tooltip = "Purchase Items From Anywhere",
			Searchable = true,
			Callback = function(Value)
				local args = {
					"BuyItemTool",
					Value
				}
				game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("ServerEvent"):FireServer(unpack(args))

				Library:Notify({
					Title = "Auto Purchase",
					Description = "Purchased: " .. Value,
					Time = 2,
				})
				task.wait(0.1)

				local args = {
					Value
				}
				game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("PurchaseSeed"):FireServer(unpack(args))


			end,
		})



		local TeleportSection = Tabs.Main:AddRightGroupbox("Teleport", "log-in")


		local teleportNames = {}
		for name in pairs(TELEPORT_LOCATIONS) do
			table.insert(teleportNames, name)
		end

		TeleportSection:AddDropdown("TeleportDropdown", {
			Values = teleportNames,
			Default = 1,
			Text = "Teleport To",
			Tooltip = "Select a place to teleport",
			Searchable = true,
			Callback = function(Value)
				local character = LocalPlayer.Character
				if character and TELEPORT_LOCATIONS[Value] then
					local root = character:FindFirstChild("HumanoidRootPart")
					if root then
						root.CFrame = TELEPORT_LOCATIONS[Value]
						Library:Notify({
							Title = "Teleport",
							Description = "Teleported to: " .. Value,
							Time = 2,
						})
					end
				end
			end,
		})


		-- Player Grief Section
		local GriefSection = Tabs.Main:AddRightGroupbox("Lobby", "users")


		local selectedPlayer = nil
		local bringingPlayer = false
		local viewingPlayer = false
		local currentViewConnection = nil

		-- Get player list function
		local function GetPlayerNames()
			local names = {}
			for _, player in ipairs(Players:GetPlayers()) do
				if player ~= LocalPlayer then
					table.insert(names, player.Name)
				end
			end
			return names
		end

		-- Player dropdown
		local playerDropdown = GriefSection:AddDropdown("PlayerDropdown", {
			Values = GetPlayerNames(),
			Default = 1,
			Text = "Players in Lobby",
			Tooltip = "Select a player",
			Searchable = true,
			Callback = function(Value)
				selectedPlayer = Value
			end,
		})

		-- Update player list when players join/leave
		Players.PlayerAdded:Connect(function()
			task.wait(0.5)
			playerDropdown:SetValues(GetPlayerNames())
		end)

		Players.PlayerRemoving:Connect(function(player)
			task.wait(0.5)
			playerDropdown:SetValues(GetPlayerNames())
			if selectedPlayer == player.Name then
				selectedPlayer = nil
				if bringingPlayer then Toggles.BringPlayer:SetValue(false) end
				if viewingPlayer then Toggles.ViewPlayer:SetValue(false) end
			end
		end)

		-- Teleport to Player
		GriefSection:AddToggle("TeleportToPlayer", {
			Text = "Teleport to Player",
			Default = false,
			Tooltip = "Teleports to selected player once",
			Callback = function(Value)
				if Value then
					if not selectedPlayer then
						Library:Notify({ Title = "Error", Description = "No player selected!", Time = 2 })
						Toggles.TeleportToPlayer:SetValue(false)
						return
					end

					local target = Players:FindFirstChild(selectedPlayer)
					local character = LocalPlayer.Character
					if target and target.Character and character then
						local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
						local myRoot = character:FindFirstChild("HumanoidRootPart")
						if targetRoot and myRoot then
							myRoot.CFrame = targetRoot.CFrame + Vector3.new(0, 3, 0)
							Library:Notify({ Title = "Teleport", Description = "Teleported to " .. selectedPlayer, Time = 2 })
						end
					end
					task.wait(0.2)
					Toggles.TeleportToPlayer:SetValue(false)
				end
			end,
		})

		-- Bring Player
		GriefSection:AddToggle("BringPlayer", {
			Text = "Bring Player",
			Default = false,
			Tooltip = "Continuously brings selected player to you",
			Callback = function(Value)
				bringingPlayer = Value
				if Value then
					if not selectedPlayer then
						Library:Notify({ Title = "Error", Description = "No player selected!", Time = 2 })
						Toggles.BringPlayer:SetValue(false)
						return
					end
					Library:Notify({ Title = "Bring", Description = "Bringing " .. selectedPlayer, Time = 2 })
				else
					Library:Notify({ Title = "Bring", Description = "Stopped bringing player", Time = 2 })
				end
			end,
		})

		-- View Player
		GriefSection:AddToggle("ViewPlayer", {
			Text = "View Selected Player",
			Default = false,
			Tooltip = "Spectate selected player",
			Callback = function(Value)
				viewingPlayer = Value
				local camera = workspace.CurrentCamera

				if Value then
					if not selectedPlayer then
						Library:Notify({ Title = "Error", Description = "No player selected!", Time = 2 })
						Toggles.ViewPlayer:SetValue(false)
						return
					end

					local target = Players:FindFirstChild(selectedPlayer)

					if target and target.Character then
						-- Store the original camera subject
						originalCameraSubject = camera.CameraSubject

						-- Set up the camera to follow the target's humanoid
						camera.CameraSubject = target.Character:FindFirstChildOfClass("Humanoid")

						-- Store the original metatable hook for cleanup
						if not viewPlayerHook then
							local mt = getrawmetatable(game)
							setreadonly(mt, false)

							local oldIndex; oldIndex = hookmetamethod(game, "__newindex", function(self, key, value)
								if self == camera and key == "CameraSubject" then
									-- Prevent camera subject from being changed
									return
								end
								return oldIndex(self, key, value)
							end)

							viewPlayerHook = oldIndex
							setreadonly(mt, true)
						end

						-- Handle character respawns
						if currentViewConnection then
							currentViewConnection:Disconnect()
						end

						currentViewConnection = target.CharacterAdded:Connect(function(newChar)
							local humanoid = newChar:WaitForChild("Humanoid")
							camera.CameraSubject = humanoid
						end)
					else
						Library:Notify({ Title = "Error", Description = "Target player or character not found!", Time = 2 })
						Toggles.ViewPlayer:SetValue(false)
					end
				else
					-- Disable viewer mode
					if currentViewConnection then
						currentViewConnection:Disconnect()
						currentViewConnection = nil
					end

					-- Clean up metatable hook
					if viewPlayerHook then
						local mt = getrawmetatable(game)
						setreadonly(mt, false)
						hookmetamethod(game, "__newindex", viewPlayerHook)
						viewPlayerHook = nil
						setreadonly(mt, true)
					end

					-- Restore original camera subject
					if LocalPlayer.Character then
						camera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
					elseif originalCameraSubject then
						camera.CameraSubject = originalCameraSubject
					end
				end
			end,
		})

		-- Bring player loop
		game:GetService("RunService").Heartbeat:Connect(function()
			if bringingPlayer and selectedPlayer then
				local target = Players:FindFirstChild(selectedPlayer)
				local myCharacter = LocalPlayer.Character
				if target and target.Character and myCharacter then
					local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
					local myRoot = myCharacter:FindFirstChild("HumanoidRootPart")
					if targetRoot and myRoot then
						targetRoot.CFrame = myRoot.CFrame + Vector3.new(0, 3, 0)
					else
						Toggles.BringPlayer:SetValue(false)
					end
				else
					Toggles.BringPlayer:SetValue(false)
				end
			end
		end)

		local vehicle = Tabs.Main:AddRightGroupbox("Vehicle", "car")

		local carfolder = game:GetService("ReplicatedStorage").Elements.CarModels

		local cars = {}
		for _, whips in pairs(carfolder:GetChildren()) do
			table.insert(cars, whips.Name)
		end

		local playerDropdown = vehicle:AddDropdown("PlayerDropdown", {
			Values = cars,
			Default = 1,
			Text = "Spawn Vehicle",
			Tooltip = "Spawn Your Car",
			Searchable = true,
			Callback = function(Value)
				getinsidecar = Value

				local args = {
					"SpawnVehicle",
					Value
				}
				game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("VehicleEvent"):FireServer(unpack(args))

				Library:Notify({
					Title = "Vehicle",
					Description = "Spawned: " .. Value,
					Time = 2,
				})

			end,
		})

		local MyButton = vehicle:AddButton({
			Text = "Teleport To Vehicle",
			Func = function()
				local root = game.Players.LocalPlayer.Character.HumanoidRootPart
				local userId = game.Players.LocalPlayer.UserId
				local carholder = workspace.Cars

				for _, vehicles in pairs(carholder:GetChildren()) do
					if vehicles.Name == "Car_" .. userId then
						root.CFrame = vehicles.DriveSeat.CFrame

						Library:Notify({
							Title = "Vehicle",
							Description = "Teleported To: " .. getinsidecar,
							Time = 2,
						})

					end
				end
			end,
			DoubleClick = false,

			Tooltip = "Teleport To Your Vehicle",
			DisabledTooltip = "I am disabled!",

			Disabled = false, -- Will disable the button (true / false)
			Visible = true, -- Will make the button invisible (true / false)
			Risky = false, -- Makes the text red (the color can be changed using Library.Scheme.Red) (Default value = false)
		})

		local Spawnersec = Tabs.Main:AddRightGroupbox("Spawners", "radio-tower")

		local gunfolder = game:GetService("ReplicatedStorage").Elements.ItemsFolder


		local guns = {}
		for _, sticks in pairs(gunfolder:GetChildren()) do
			table.insert(guns, sticks.Name)
		end

		-- AUTO UUID STEALER (runs once and fills uuidfuckniiga forever)
		_G.uuidfuckniiga = _G.uuidfuckniiga or nil

		spawn(function()
			local remote = game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("StartPackaging")

			local old
			old = hookmetamethod(game, "__namecall", function(self, ...)
				if not checkcaller() and self == remote and getnamecallmethod() == "FireServer" and not _G.uuidfuckniiga then
					local args = {...}
					if args[1] and type(args[1]) == "string" and string.len(args[1]) == 36 then
						_G.uuidfuckniiga = args[1]
						print("UUID AUTO-STOLEN →", _G.uuidfuckniiga)
						if setclipboard then setclipboard(_G.uuidfuckniiga) end -- bonus copy
					end
				end
				return old(self, ...)
			end)
		end)

		-- Your dropdown (now works instantly after you spawn one thing once)
		Spawnersec:AddDropdown("TeleportDropdown", {
			Values = guns,
			Default = 1,
			Text = "Spawn Items",
			Tooltip = "Spawn Any Item For Free",
			Searchable = true,
			Callback = function(Value)

				local args = {
					text,   -- automatically filled
					"Spawning",
					"Raspberry",
					0,
					Value,               -- the gun/item you picked
					0
				}

				game:GetService("ReplicatedStorage").Remotes.StartPackaging:FireServer(unpack(args))
			end
		})

		Spawnersec:AddInput("MyTextbox", {
			Default = "Enter Machines Code(Aka Pasted To Your Clipboard)",
			Numeric = false, -- true / false, only allows numbers
			Finished = false, -- true / false, only calls callback when you press enter
			ClearTextOnFocus = true, -- true / false, if false the text will not clear when textbox focused

			Text = "Machines Code",
			Tooltip = "Makes it work!", -- Information shown when you hover over the textbox

			Placeholder = "Placeholder text", -- placeholder text when the box is empty
			-- MaxLength is also an option which is the max length of the text

			Callback = function(Value)
				text = Value
			end,
		})


		Spawnersec:AddButton({
			Text = "Grab Machines Code",
			Func = function()
				_G.uuidfuckniiga = nil
				print("UUID cleared — spawn one thing again to re-steal")
			end
		})

		local Miscsec = Tabs.Main:AddRightGroupbox("Misc", "badge-plus")

		local MyButton = Miscsec:AddButton({
			Text = "Teleport To A Safe",
			Func = function()
				local root = game.Players.LocalPlayer.Character.HumanoidRootPart

				root.CFrame = CFrame.new(1429, 142, 82)
			end,
			DoubleClick = false,

			Tooltip = "Store Weapons",
			DisabledTooltip = "I am disabled!",

			Disabled = false, -- Will disable the button (true / false)
			Visible = true, -- Will make the button invisible (true / false)
			Risky = false, -- Makes the text red (the color can be changed using Library.Scheme.Red) (Default value = false)
		})

		local Gunmods = Tabs.Main:AddLeftGroupbox("Gun Mods", "swords")

		local MyButton = Gunmods:AddButton({
			Text = "Full Auto",
			Func = function()
				local back = game.Players.LocalPlayer.Backpack

				for _, gun in pairs(back:GetChildren()) do
					if gun:IsA("Tool") and gun:FindFirstChild("BPerfectionWeld") then
						local gunModule = require(game:GetService("ReplicatedStorage").GunMetadata.Metadata[gun.Name])

						-- Modify the module
						gunModule.FireMode = "Auto"

						Library:Notify({
							Title = "Gun Mod",
							Description = "Applied",
							Time = 2,
						})

					end
				end
			end,
			DoubleClick = false,

			Tooltip = "Weapon Mod",
			DisabledTooltip = "I am disabled!",

			Disabled = false, -- Will disable the button (true / false)
			Visible = true, -- Will make the button invisible (true / false)
			Risky = false, -- Makes the text red (the color can be changed using Library.Scheme.Red) (Default value = false)
		})

		local MyButton = Gunmods:AddButton({
			Text = "No Recoil",
			Func = function()
				local back = game.Players.LocalPlayer.Backpack

				for _, gun in pairs(back:GetChildren()) do
					if gun:IsA("Tool") and gun:FindFirstChild("BPerfectionWeld") then
						local gunModule = require(game:GetService("ReplicatedStorage").GunMetadata.Metadata[gun.Name])


						gunModule.Recoil.Magnitude = 0
						gunModule.Recoil.Roughness = 0
						gunModule.Recoil.FadeInTime = 0
						gunModule.Recoil.FadeOutTime = 0
						gunModule.Recoil.PositionInfluence = 0
						gunModule.Recoil.RotationInfluence = 0

						Library:Notify({
							Title = "Gun Mod",
							Description = "Applied",
							Time = 2,
						})

					end
				end
			end,
			DoubleClick = false,

			Tooltip = "Weapon Mod",
			DisabledTooltip = "I am disabled!",

			Disabled = false, -- Will disable the button (true / false)
			Visible = true, -- Will make the button invisible (true / false)
			Risky = false, -- Makes the text red (the color can be changed using Library.Scheme.Red) (Default value = false)
		})


		local MyButton = Gunmods:AddButton({
			Text = "Infinite Ammo",
			Func = function()
				local back = game.Players.LocalPlayer.Backpack

				for _, gun in pairs(back:GetChildren()) do
					if gun:IsA("Tool") and gun:FindFirstChild("BPerfectionWeld") then
						local gunModule = require(game:GetService("ReplicatedStorage").GunMetadata.Metadata[gun.Name])


						gunModule.InMag = math.huge
						gunModule.MagMax = math.huge

						Library:Notify({
							Title = "Gun Mod",
							Description = "Applied",
							Time = 2,
						})

					end
				end
			end,
			DoubleClick = false,

			Tooltip = "Weapon Mod",
			DisabledTooltip = "I am disabled!",

			Disabled = false, -- Will disable the button (true / false)
			Visible = true, -- Will make the button invisible (true / false)
			Risky = false, -- Makes the text red (the color can be changed using Library.Scheme.Red) (Default value = false)
		})

		local MyButton = Gunmods:AddButton({
			Text = "Fast Equip",
			Func = function()
				local back = game.Players.LocalPlayer.Backpack

				for _, gun in pairs(back:GetChildren()) do
					if gun:IsA("Tool") and gun:FindFirstChild("BPerfectionWeld") then
						local gunModule = require(game:GetService("ReplicatedStorage").GunMetadata.Metadata[gun.Name])


						gunModule.EquipWait = 0

						Library:Notify({
							Title = "Gun Mod",
							Description = "Applied",
							Time = 2,
						})

					end
				end
			end,
			DoubleClick = false,

			Tooltip = "Weapon Mod",
			DisabledTooltip = "I am disabled!",

			Disabled = false, -- Will disable the button (true / false)
			Visible = true, -- Will make the button invisible (true / false)
			Risky = false, -- Makes the text red (the color can be changed using Library.Scheme.Red) (Default value = false)
		})

		local MyButton = Gunmods:AddButton({
			Text = "Fast FireRate",
			Func = function()
				local back = game.Players.LocalPlayer.Backpack

				for _, gun in pairs(back:GetChildren()) do
					if gun:IsA("Tool") and gun:FindFirstChild("BPerfectionWeld") then
						local gunModule = require(game:GetService("ReplicatedStorage").GunMetadata.Metadata[gun.Name])


						gunModule.FireRate = 0

						Library:Notify({
							Title = "Gun Mod",
							Description = "Applied",
							Time = 2,
						})

					end
				end
			end,
			DoubleClick = false,

			Tooltip = "Weapon Mod",
			DisabledTooltip = "I am disabled!",

			Disabled = false, -- Will disable the button (true / false)
			Visible = true, -- Will make the button invisible (true / false)
			Risky = false, -- Makes the text red (the color can be changed using Library.Scheme.Red) (Default value = false)
		})


		local MyButton = Gunmods:AddButton({
			Text = "Never Jam",
			Func = function()
				local back = game.Players.LocalPlayer.Backpack

				for _, gun in pairs(back:GetChildren()) do
					if gun:IsA("Tool") and gun:FindFirstChild("BPerfectionWeld") then
						local gunModule = require(game:GetService("ReplicatedStorage").GunMetadata.Metadata[gun.Name])


						gunModule.JamChance = 0

						Library:Notify({
							Title = "Gun Mod",
							Description = "Applied",
							Time = 2,
						})

					end
				end
			end,
			DoubleClick = false,

			Tooltip = "Weapon Mod",
			DisabledTooltip = "I am disabled!",

			Disabled = false, -- Will disable the button (true / false)
			Visible = true, -- Will make the button invisible (true / false)
			Risky = false, -- Makes the text red (the color can be changed using Library.Scheme.Red) (Default value = false)
		})



		local MyButton = Gunmods:AddButton({
			Text = "One Tap",
			Func = function()
				local back = game.Players.LocalPlayer.Backpack

				for _, gun in pairs(back:GetChildren()) do
					if gun:IsA("Tool") and gun:FindFirstChild("BPerfectionWeld") then
						local gunModule = require(game:GetService("ReplicatedStorage").GunMetadata.Metadata[gun.Name])


						gunModule.BaseDamage = 1000000

						Library:Notify({
							Title = "Gun Mod",
							Description = "Applied",
							Time = 2,
						})

					end
				end
			end,
			DoubleClick = false,

			Tooltip = "Weapon Mod",
			DisabledTooltip = "I am disabled!",

			Disabled = false, -- Will disable the button (true / false)
			Visible = true, -- Will make the button invisible (true / false)
			Risky = false, -- Makes the text red (the color can be changed using Library.Scheme.Red) (Default value = false)
		})

		-- ESP System (Combat Tab)
		getgenv().global = getgenv()

		function global.declare(self, index, value, check)
			if self[index] == nil then
				self[index] = value
			elseif check then
				local methods = { "remove", "Disconnect" }
				for _, method in ipairs(methods) do
					pcall(function()
						value[method](value)
					end)
				end
			end
			return self[index]
		end

		declare(global, "services", {})
		function global.get(service) return services[service] end

		declare(declare(services, "loop", {}), "cache", {})
		get("loop").new = function(self, index, func, disabled)
			if disabled == nil and (func == nil or typeof(func) == "boolean") then
				disabled = func func = index
			end

			self.cache[index] = {
				["enabled"] = (not disabled),
				["func"] = func,
				["toggle"] = function(self, boolean)
					self.enabled = boolean ~= nil and boolean or not self.enabled
				end,
				["remove"] = function() self.cache[index] = nil end
			}
			return self.cache[index]
		end

		declare(
			get("loop"),
			"connection",
			game:GetService("RunService").RenderStepped:Connect(function(delta)
				for _, loop in pairs(get("loop").cache) do
					if loop.enabled then
						local success, result = pcall(loop.func, delta)
						warn(result)
					end
				end
			end),
			true
		)


		declare(services, "new", {})
		get("new").drawing = function(class, properties)
			local drawing = Drawing.new(class)
			for property, value in pairs(properties) do
				pcall(function() drawing[property] = value end)
			end
			return drawing
		end

		declare(declare(services, "player", {}), "cache", {})
		get("player").find = function(self, player)
			for character, data in pairs(self.cache) do
				if data.player == player then return character end
			end
		end

		get("player").check = function(self, player)
			local success = pcall(function()
				local character = player:IsA("Player") and player.Character or player
				return character and character:FindFirstChild("Humanoid") and character:FindFirstChild("HumanoidRootPart")
			end)
			return success
		end

		get("player").new = function(self, player)
			local function cache(character)
				self.cache[character] = {
					["player"] = player,
					["drawings"] = {
						["box"] = get("new").drawing("Square", { Visible = false }),
						["boxFilled"] = get("new").drawing("Square", { Visible = false, Filled = true }),
						["boxOutline"] = get("new").drawing("Square", { Visible = false }),
						["name"] = get("new").drawing("Text", { Visible = false, Center = true }),
						["health"] = get("new").drawing("Line", { Visible = false }),
						["healthOutline"] = get("new").drawing("Line", { Visible = false }),
						["healthText"] = get("new").drawing("Text", { Visible = false, Center = false }),
						["distance"] = get("new").drawing("Text", { Visible = false, Center = true }),
						["weapon"] = get("new").drawing("Text", { Visible = false, Center = true }),
					}
				}
			end

			local function check(character)
				if self:check(character) then
					cache(character)
				else
					local listener = character.ChildAdded:Connect(function()
						if self:check(character) then
							cache(character) listener:Disconnect()
						end
					end)
				end
			end

			if player.Character then check(player.Character) end
			player.CharacterAdded:Connect(check)
		end

		get("player").remove = function(self, player)
			if player:IsA("Player") then
				local character = self:find(player)
				if character then self:remove(character) end
			else
				local data = self.cache[player]
				if data then
					for _, drawing in pairs(data.drawings) do
						drawing:Remove()
					end
					self.cache[player] = nil
				end
			end
		end

		get("player").update = function(self, character, data)
			if not self:check(character) then
				self:remove(character) return
			end

			local player = data.player
			local root = character.HumanoidRootPart
			local humanoid = character.Humanoid
			local drawings = data.drawings

			if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
				data.distance = (LocalPlayer.Character.HumanoidRootPart.Position - root.Position).Magnitude
			end

			local weapon = character:FindFirstChildWhichIsA("Tool") and character:FindFirstChildWhichIsA("Tool").Name or "none"

			task.spawn(function()
				local position, visible = Camera:WorldToViewportPoint(root.Position)
				local visuals = features.visuals

				local function shouldShow()
					local teamCheck = not visuals.teamCheck or player.Team ~= LocalPlayer.Team
					return visuals.enabled and data.distance and data.distance <= visuals.renderDistance and teamCheck
				end

				local function getColor(defaultColor)
					return visuals.teamColor and player.TeamColor.Color or defaultColor
				end

				if visible and shouldShow() then
					local scale = 1 / (position.Z * math.tan(math.rad(Camera.FieldOfView * 0.5)) * 2) * 1000
					local width, height = math.floor(4.5 * scale), math.floor(6 * scale)
					local x, y = math.floor(position.X), math.floor(position.Y)
					local xPos, yPos = math.floor(x - width * 0.5), math.floor((y - height * 0.5) + (0.5 * scale))

					-- Update box drawings
					drawings.box.Size = Vector2.new(width, height)
					drawings.box.Position = Vector2.new(xPos, yPos)
					drawings.boxFilled.Size = drawings.box.Size
					drawings.boxFilled.Position = drawings.box.Position
					drawings.boxOutline.Size = drawings.box.Size
					drawings.boxOutline.Position = drawings.box.Position

					drawings.box.Color = getColor(visuals.boxes.color)
					drawings.box.Thickness = 1
					drawings.boxFilled.Color = getColor(visuals.boxes.filled.color)
					drawings.boxFilled.Transparency = visuals.boxes.filled.transparency
					drawings.boxOutline.Color = visuals.boxes.outline.color
					drawings.boxOutline.Thickness = 3

					drawings.boxOutline.ZIndex = drawings.box.ZIndex - 1
					drawings.boxFilled.ZIndex = drawings.boxOutline.ZIndex - 1

					-- Update name
					drawings.name.Text = "[" .. player.Name .. "]"
					drawings.name.Size = math.max(math.min(12.5 * scale, 12.5), 10)
					drawings.name.Position = Vector2.new(x, (yPos - drawings.name.TextBounds.Y) - 2)
					drawings.name.Color = getColor(visuals.names.color)
					drawings.name.Outline = visuals.names.outline.enabled
					drawings.name.OutlineColor = visuals.names.outline.color

					-- Update health
					local healthPercent = math.clamp(humanoid.Health / humanoid.MaxHealth * 100, 0, 100)
					drawings.healthOutline.From = Vector2.new(xPos - 5, yPos)
					drawings.healthOutline.To = Vector2.new(xPos - 5, yPos + height)
					drawings.health.From = Vector2.new(xPos - 5, (yPos + height) - 1)
					drawings.health.To = Vector2.new(xPos - 5, (drawings.health.From.Y - ((height / 100) * healthPercent)) + 2)
					drawings.healthText.Text = "[ HP " .. math.floor(humanoid.Health) .. " ]"
					drawings.healthText.Size = math.max(math.min(11 * scale, 11), 10)
					drawings.healthText.Position = Vector2.new(drawings.health.To.X - (drawings.healthText.TextBounds.X + 3), (drawings.health.To.Y - (2 / scale)))

					drawings.health.Color = visuals.health.colorLow:Lerp(visuals.health.color, healthPercent * 0.01)
					drawings.healthOutline.Color = visuals.health.outline.color
					drawings.healthOutline.Thickness = 3
					drawings.healthText.Color = drawings.health.Color
					drawings.healthText.Outline = visuals.health.text.outline.enabled
					drawings.healthText.OutlineColor = visuals.health.outline.color

					-- Update distance
					drawings.distance.Text = "[ " .. math.floor(data.distance) .. " ]"
					drawings.distance.Size = math.max(math.min(11 * scale, 11), 10)
					drawings.distance.Position = Vector2.new(x, (yPos + height) + (drawings.distance.TextBounds.Y * 0.25))
					drawings.distance.Color = getColor(visuals.distance.color)
					drawings.distance.Outline = visuals.distance.outline.enabled
					drawings.distance.OutlineColor = visuals.distance.outline.color

					-- Update weapon
					drawings.weapon.Text = "[ " .. weapon .. " ]"
					drawings.weapon.Size = math.max(math.min(11 * scale, 11), 10)
					drawings.weapon.Position = Vector2.new(drawings.distance.Position.x, drawings.distance.Position.Y + drawings.weapon.TextBounds.Y)
					drawings.weapon.Color = getColor(visuals.weapon.color)
					drawings.weapon.Outline = visuals.weapon.outline.enabled
					drawings.weapon.OutlineColor = visuals.weapon.outline.color
				end

				local show = shouldShow() and visible
				drawings.box.Visible = show and visuals.boxes.enabled
				drawings.boxFilled.Visible = show and visuals.boxes.filled.enabled
				drawings.boxOutline.Visible = show and visuals.boxes.outline.enabled
				drawings.name.Visible = show and visuals.names.enabled
				drawings.health.Visible = show and visuals.health.enabled
				drawings.healthOutline.Visible = show and visuals.health.outline.enabled
				drawings.healthText.Visible = show and visuals.health.text.enabled
				drawings.distance.Visible = show and visuals.distance.enabled
				drawings.weapon.Visible = show and visuals.weapon.enabled
			end)
		end

		declare(get("player"), "loop", get("loop"):new(function()
			for character, data in pairs(get("player").cache) do
				get("player"):update(character, data)
			end
		end), true)

		declare(global, "features", {})
		features.toggle = function(self, feature, boolean)
			if self[feature] then
				self[feature].enabled = boolean ~= nil and boolean or not self[feature].enabled
				if self[feature].toggle then
					task.spawn(self[feature].toggle)
				end
			end
		end

		-- Visuals Configuration
		declare(features, "visuals", {
			enabled = false,
			teamCheck = false,
			teamColor = false,
			renderDistance = 2000,
			boxes = { enabled = false, color = Color3.fromRGB(255, 255, 255), outline = { enabled = false, color = Color3.fromRGB(0, 0, 0) }, filled = { enabled = false, color = Color3.fromRGB(255, 255, 255), transparency = 0.25 } },
			names = { enabled = false, color = Color3.fromRGB(255, 255, 255), outline = { enabled = false, color = Color3.fromRGB(0, 0, 0) } },
			health = { enabled = false, color = Color3.fromRGB(0, 255, 0), colorLow = Color3.fromRGB(255, 0, 0), outline = { enabled = false, color = Color3.fromRGB(0, 0, 0) }, text = { enabled = false, outline = { enabled = false } } },
			distance = { enabled = false, color = Color3.fromRGB(255, 255, 255), outline = { enabled = false, color = Color3.fromRGB(0, 0, 0) } },
			weapon = { enabled = false, color = Color3.fromRGB(255, 255, 255), outline = { enabled = false, color = Color3.fromRGB(0, 0, 0) } }
		})

		-- Visuals UI
		local VisualsSection = Tabs.Visuals:AddLeftGroupbox("Visuals")

		-- Main Settings
		VisualsSection:AddDivider("Main Settings")
		VisualsSection:AddToggle("VisualsEnabled", {
			Text = "Enable Visuals",
			Default = false,
			Callback = function(value) features:toggle("visuals", value) end
		})

		VisualsSection:AddToggle("TeamCheck", {
			Text = "Team Check",
			Default = false,
			Callback = function(value) features.visuals.teamCheck = value end
		})

		VisualsSection:AddToggle("TeamColor", {
			Text = "Team Color",
			Default = false,
			Callback = function(value) features.visuals.teamColor = value end
		})

		VisualsSection:AddSlider("RenderDistance", {
			Text = "Render Distance",
			Default = 2000,
			Min = 0,
			Max = 5000,
			Rounding = 0,
			Callback = function(value) features.visuals.renderDistance = value end
		})

		-- Box ESP
		VisualsSection:AddDivider("Box ESP")
		VisualsSection:AddToggle("BoxESP", {
			Text = "Box ESP",
			Default = false,
			Callback = function(value) features.visuals.boxes.enabled = value end
		})

		VisualsSection:AddToggle("BoxFilled", {
			Text = "Box Filled",
			Default = false,
			Callback = function(value) features.visuals.boxes.filled.enabled = value end
		})

		VisualsSection:AddToggle("BoxOutline", {
			Text = "Box Outline",
			Default = false,
			Callback = function(value) features.visuals.boxes.outline.enabled = value end
		})

		-- Name ESP
		VisualsSection:AddDivider("Name ESP")
		VisualsSection:AddToggle("NameESP", {
			Text = "Name ESP",
			Default = false,
			Callback = function(value) features.visuals.names.enabled = value end
		})

		VisualsSection:AddToggle("NameOutline", {
			Text = "Name Outline",
			Default = false,
			Callback = function(value) features.visuals.names.outline.enabled = value end
		})

		-- Health ESP
		VisualsSection:AddDivider("Health ESP")
		VisualsSection:AddToggle("HealthESP", {
			Text = "Health ESP",
			Default = false,
			Callback = function(value) features.visuals.health.enabled = value end
		})

		VisualsSection:AddToggle("HealthOutline", {
			Text = "Health Outline",
			Default = false,
			Callback = function(value) features.visuals.health.outline.enabled = value end
		})

		VisualsSection:AddToggle("HealthText", {
			Text = "Health Text",
			Default = false,
			Callback = function(value) features.visuals.health.text.enabled = value end
		})

		-- Distance ESP
		VisualsSection:AddDivider("Distance ESP")
		VisualsSection:AddToggle("DistanceESP", {
			Text = "Distance ESP",
			Default = false,
			Callback = function(value) features.visuals.distance.enabled = value end
		})

		VisualsSection:AddToggle("DistanceOutline", {
			Text = "Distance Outline",
			Default = false,
			Callback = function(value) features.visuals.distance.outline.enabled = value end
		})

		-- Weapon ESP
		VisualsSection:AddDivider("Weapon ESP")
		VisualsSection:AddToggle("WeaponESP", {
			Text = "Weapon ESP",
			Default = false,
			Callback = function(value) features.visuals.weapon.enabled = value end
		})

		VisualsSection:AddToggle("WeaponOutline", {
			Text = "Weapon Outline",
			Default = false,
			Callback = function(value) features.visuals.weapon.outline.enabled = value end
		})

		for _, player in ipairs(Players:GetPlayers()) do
			if player ~= LocalPlayer then
				get("player"):new(player)
			end
		end

		declare(get("player"), "added", Players.PlayerAdded:Connect(function(player)
			get("player"):new(player)
		end), true)

		declare(get("player"), "removing", Players.PlayerRemoving:Connect(function(player)
			get("player"):remove(player)
		end), true)


		-- UI Settings
		local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu")

		MenuGroup:AddToggle("KeybindMenu", {
			Text = "Open Keybind Menu",
			Default = Library.KeybindFrame.Visible,
			Callback = function(value) Library.KeybindFrame.Visible = value end,
		})

		MenuGroup:AddToggle("CustomCursor", {
			Text = "Custom Cursor",
			Default = true,
			Callback = function(value) Library.ShowCustomCursor = value end,
		})

		MenuGroup:AddDropdown("NotificationSide", {
			Values = { "Left", "Right" },
			Default = "Right",
			Text = "Notification Side",
			Callback = function(value) Library:SetNotifySide(value) end,
		})

		MenuGroup:AddDropdown("DPIScale", {
			Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
			Default = "100%",
			Text = "DPI Scale",
			Callback = function(value)
				local scale = tonumber(value:gsub("%%", "")) / 100
				Library:SetDPIScale(scale)
			end,
		})

		MenuGroup:AddDivider()
		MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { 
			Default = "RightShift", 
			NoUI = true, 
			Text = "Menu keybind" 
		})

		MenuGroup:AddButton("Unload Script", function()
			Library:Unload()
		end)

		-- Set keybinds and theme management
		Library.ToggleKeybind = Options.MenuKeybind

		ThemeManager:SetLibrary(Library)
		SaveManager:SetLibrary(Library)
		SaveManager:IgnoreThemeSettings()
		SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

		ThemeManager:SetFolder("MyScriptHub")
		SaveManager:SetFolder("MyScriptHub/specific-game")
		SaveManager:SetSubFolder("specific-place")

		SaveManager:BuildConfigSection(Tabs["UI Settings"])
		ThemeManager:ApplyToTab(Tabs["UI Settings"])
		SaveManager:LoadAutoloadConfig()

else
    warn("You are not whitelisted")
end
